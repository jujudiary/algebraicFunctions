(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Needs["MSurfacePlots`"]
<<ComputationalGeometry`
$HistoryLength=0;

colorNumbers=Join[{14,60,45,57,24,35,43,45,32,16,32,15,17,2,7,3,14,18,21,60,45,57,21,35,43,45,32,16,32,15,17,19,12,37,49,15,7,9,13},Range[42]];
theColorList=Table[ColorData[colorNumbers[[i]],"ColorList"],{i,1,Length[colorNumbers]}];

getSave=False;
getSave2=False;
theXSize=15;
theYSize=15;
xStart=5;
xEnd=-5;
deltaX=-.5;
deltaY=.5;
totalT=30;
totalR=16;
outerRingSize=2;
holomorphicBranch=False;
theplotStyle=0;
thesingularType=0;
theinitiallogset={-1,0,1};
thesingularsubset={};
holomorphicExtension=4;
deleteDuplicateThreshold=0.001;
theplotFlag==0;
theplotrange=Automatic;
theplotRange=Automatic;
theBoxRatios={1,1,1};
ringSeparationThreshold=0.0001;
thetStart=0;
theMaxStepSize= Automatic;
theImageSize={700,700};
editSectorLatch=False;
manualRingSelection={};
theMaxSteps=500000;
theOpacity=0;
startOfBranch=0;
trace1Latch=False;
trace2Latch=False;
trace3Latch=False;
trace4Latch=False;
trace5Latch=False;
trace6Latch=False;
trace7Latch=False;
trace8Latch=False;






(* ::Input::Initialization:: *)
FourierSmooth[Graphics[{___,Style[Line[pts_],___],___}],numFourCoeff_Integer]:=Module[{wx,wy,ftsum,w,nn},
If[numFourCoeff<1||numFourCoeff>nn/2,
Return[$Failed]
];
nn=Length[pts];
{wx,wy}=Fourier/@Transpose[pts];
ftsum[t_]:=Evaluate[1/Sqrt[nn](w[1]+Sum[2w[i+1]*Exp[-2Pi I t i/nn],{i,1,numFourCoeff}])];
Show[{
Graphics[{Gray,Dashed,Line[pts]}],
ParametricPlot[Re[ftsum[t]]/.w[i__]:>{wx[[i]],wy[[i]]},{t,0,nn},PlotStyle->{Magenta},Axes->False,Frame->True]
}]
]

FourierSmooth2[Graphics[Style[Line[pts_],___]],numFourCoeff_Integer]:=Module[{wx,wy,ftsum,w,nn},
If[numFourCoeff<1||numFourCoeff>nn/2,
Return[$Failed]
];
nn=Length[pts];
{wx,wy}=Fourier/@Transpose[pts];
ftsum[t_]:=Evaluate[1/Sqrt[nn](w[1]+Sum[2w[i+1]*Exp[-2Pi I t i/nn],{i,1,numFourCoeff}])];
Show[{
Graphics[{Gray,Dashed,Line[pts]}],
ParametricPlot[Re[ftsum[t]]/.w[i__]:>{wx[[i]],wy[[i]]},{t,0,nn},PlotStyle->{Magenta},Axes->False,Frame->True]
}]
]



(* ::Input::Initialization:: *)
getNewPoints[p1_,p2_,a_]:=Module[{x1,y1,z1,x2,y2,z2,myangle,alpha,bval,slope,newx,newy,zdif,base,xdif,newz},
x1=p1[[1]];
y1=p1[[2]];
z1=p1[[3]];
x2=p2[[1]];
y2=p2[[2]];
z2=p2[[3]];
myangle=a;
alpha=Tan[myangle];
If[x1>x2,
x1=p2[[1]];
y1=p2[[2]];
z1=p2[[3]];
x2=p1[[1]];
y2=p1[[2]];
z2=p1[[3]];
];
slope=(y2-y1)/(x2-x1+0.00001);
bval=y1-slope x1;
newx=bval/(alpha-slope+0.00001);
newy=alpha newx;
zdif=Abs[z1-z2];
base=Sqrt[(x1-x2)^2+(y1-y2)^2];
xdif=Sqrt[(x1-newx)^2+(y1-newy)^2];
If[z2<z1,xdif=base-xdif];
newz=N[Min[z1,z2]+(xdif zdif)/(base+0.00001)];
N[{newx,newy,newz}]
];



thePoleSolution
thePointPoles


(* ::Input::Initialization:: *)
identifySingularities:=Module[{},
If[!MemberQ[theFunction,Symbol["z"],\[Infinity]] || !MemberQ[theFunction,Symbol["w"],\[Infinity]] ,
Print["Error with function specification"];
];
While[(theFunction/.z->0)==0,
{
theFunction=Expand[theFunction/z];
Print["Factoring z out of function to: ", theFunction]
}
];
While[(theFunction/.w->0)==0,
{
theFunction=Expand[theFunction/w];
Print["Factoring w out of function to: ", theFunction]
}
];
theCoefficients=CoefficientList[theFunction,w];
theFunctionDegree=Length[theCoefficients]-1;
thea0list=theCoefficients[[1]];
theanlist=theCoefficients[[Length[theCoefficients]]];
thePoleSolution=NSolve[theanlist==0,z];
If[Length[thePoleSolution]>0,
thePoles=(z/.thePoleSolution)
,
thePoles={}
];
theZeroSolution=NSolve[thea0list==0,z];
If[Length[theZeroSolution]>0,
theZeros=(z/.theZeroSolution)
,
theZeros={}
];

partialW=D[theFunction,w];

theZFlag=False;
While[(partialW/.z->0)==0,
{
theZFlag=True;
partialW=Expand[partialW/z];
}
];
If[Not[IrreduciblePolynomialQ[theFunction]],
{
Print["Polynomial is reducible.  Solution set will be union of both factors"];
}
];
theInfSolution=NSolve[{theFunction==0,partialW==0},{z,w}];
If[Length[theInfSolution]>0,
theInflections=(z/.theInfSolution)
,
theInflections={}
];

If[theZFlag,
theInflections=Append[theInflections,0];
];

theSingularPoints=Join[theInflections,thePoles];

thePointPoles={Red,PointSize[0.03],Point@ {Re[#],Im[#]}& /@ thePoles};
thePointZeros={Green,PointSize[0.03],Point@ {Re[#],Im[#]}& /@ theZeros};
thePointInflections={Blue,PointSize[0.03],Point@ {Re[#],Im[#]}& /@ theInflections};

theSectorList=Sort[Abs[theSingularPoints]];

While[Length[theSectorList]>0 && Abs[theSectorList[[1]]]<ringSeparationThreshold,
{
Print["Triming ring table at origin"];
theSectorList=Delete[theSectorList,1];
}
];

If[Length[theSectorList]>0,
theSectorList=DeleteDuplicates[theSectorList,(Abs[#1-#2])<ringSeparationThreshold&]
];
theSectorList=Prepend[theSectorList,0];

theAnnularCircles=Table[Circle[{0,0},Abs[theSectorList[[n]]]],{n,1,Length[theSectorList]}];

(*theFunctionRoots=w/.NSolve[theFunction\[Equal]0,w];*)
theFunctionRoots=Table[Root[(theFunction/.w->#1)&,n],{n,1,theFunctionDegree}];

If[theSectorList[[1]]!=0,theSectorList=Prepend[theSectorList,0]];
len=Length[theSectorList];
send=theSectorList[[len]];
sfinal=send+outerRingSize;
theSectorList=Append[theSectorList,sfinal];
sectorboundaries=Table[{theSectorList[[i]],theSectorList[[i+1]]},{i,1,len}];
theSectorBoundaries=sectorboundaries;
(* now create the initial values *)
If[sectorboundaries[[1,2]]-ringSeparationThreshold<0,
{
Print["First sector size less than ring separation threshold"];
Return[False];
}
];
firsttable={ringSeparationThreshold,sectorboundaries[[1,2]]-ringSeparationThreshold,False,1};
theInitialValues=Table[rmin=sectorboundaries[[i,1]];
rmax=sectorboundaries[[i,2]];
If[Abs[rmax-rmin]<ringSeparationThreshold,
{
Print["Annular domain smaller than ring separation threshold"];
Return[False];
}
];
(* adjust  difference to accont for size of ring *)
rdif=Which[0<rmax<= 10,ringSeparationThreshold,10<rmax<= 20,10 ringSeparationThreshold,rmax>20,100 ringSeparationThreshold];
{rmin+rdif,rmax-rdif,False,i},
{i,2,Length[theSectorList]-1}];
theInitialValues=Prepend[theInitialValues,firsttable];
totalRings=Length[theInitialValues];
theStepSizeArray=Table[theMaxStepSize,{totalRings}];
Print[manualRingSelection];
If[Length[manualRingSelection]>0,
{
theInitialValues=theInitialValues[[manualRingSelection]];
totalRings=Length[theInitialValues];
}
];
Return[True];
];



(* ::Input::Initialization:: *)
identifySingularities2:=Module[{},
If[!MemberQ[theFunction,Symbol["z"],\[Infinity]] || !MemberQ[theFunction,Symbol["w"],\[Infinity]] ,
Print["Error with function specification"];
];
While[(theFunction/.z->0)==0,
{
theFunction=Expand[theFunction/z];
Print["Factoring z out of function to: ", theFunction]
}
];
While[(theFunction/.w->0)==0,
{
theFunction=Expand[theFunction/w];
Print["Factoring w out of function to: ", theFunction]
}
];
theCoefficients=CoefficientList[theFunction,w];
theFunctionDegree=Length[theCoefficients]-1;
thea0list=theCoefficients[[1]];
theanlist=theCoefficients[[Length[theCoefficients]]];
thePoleSolution=NSolve[theanlist==0,z];
If[Length[thePoleSolution]>0,
thePoles=(z/.thePoleSolution)
,
thePoles={}
];
theZeroSolution=NSolve[thea0list==0,z];
If[Length[theZeroSolution]>0,
theZeros=(z/.theZeroSolution)
,
theZeros={}
];

partialW=D[theFunction,w];

theZFlag=False;
While[(partialW/.z->0)==0,
{
theZFlag=True;
partialW=Expand[partialW/z];
}
];
If[Not[IrreduciblePolynomialQ[theFunction]],
{
Print["Polynomial is reducible.  Solution set will be union of both factors"];
}
];

theInfSolution=NSolve[{theFunction==0,partialW==0},{z,w}];
If[Length[theInfSolution]>0,
theInflections=(z/.theInfSolution)
,
theInflections={}
];

If[theZFlag,
theInflections=Append[theInflections,0];
];

theSingularPoints=Join[theInflections,thePoles];

thePointPoles={Red,PointSize[0.01],Point@ {Re[#],Im[#]}& /@ thePoles};
thePointZeros={Green,PointSize[0.01],Point@ {Re[#],Im[#]}& /@ theZeros};
thePointInflections={Blue,PointSize[0.01],Point@ {Re[#],Im[#]}& /@ theInflections};

theSectorList=Sort[Abs[theSingularPoints]];

While[Length[theSectorList]>0 && Abs[theSectorList[[1]]]<ringSeparationThreshold,
{
theSectorList=Delete[theSectorList,1];
}
];

If[Length[theSectorList]>0,
theSectorList=DeleteDuplicates[theSectorList,(Abs[#1-#2])<ringSeparationThreshold&]
];
theSectorList=Prepend[theSectorList,0];

theAnnularCircles=Table[Circle[{0,0},Abs[theSectorList[[n]]]],{n,1,Length[theSectorList]}];

(*theFunctionRoots=w/.NSolve[theFunction\[Equal]0,w];*)
theFunctionRoots=Table[Root[(theFunction/.w->#1)&,n],{n,1,theFunctionDegree}];

If[theSectorList[[1]]!=0,theSectorList=Prepend[theSectorList,0]];
len=Length[theSectorList];
send=theSectorList[[len]];
sfinal=send+outerRingSize;
theSectorList=Append[theSectorList,sfinal];
sectorboundaries=Table[{theSectorList[[i]],theSectorList[[i+1]]},{i,1,len}];
theSectorBoundaries=sectorboundaries;
(* now create the initial values *)
If[sectorboundaries[[1,2]]-ringSeparationThreshold<0,
{
Print["First sector size less than ring separation threshold"];
Return[False];
}
];
firsttable={ringSeparationThreshold,sectorboundaries[[1,2]]-ringSeparationThreshold,False,1};
theInitialValues=Table[rmin=sectorboundaries[[i,1]];
rmax=sectorboundaries[[i,2]];
If[Abs[rmax-rmin]<ringSeparationThreshold,
{
Print["Annular domain smaller than ring separation threshold"];
Return[False];
}
];
(* adjust  difference to accont for size of ring *)
rdif=Which[0<rmax<= 10,ringSeparationThreshold,10<rmax<= 20,10 ringSeparationThreshold,rmax>20,100 ringSeparationThreshold];
{rmin+rdif,rmax-rdif,False,i},
{i,2,Length[theSectorList]-1}];
theInitialValues=Prepend[theInitialValues,firsttable];
totalRings=Length[theInitialValues];
theStepSizeArray=Table[theMaxStepSize,{totalRings}];
If[Length[manualRingSelection]>0,
{
theInitialValues=theInitialValues[[manualRingSelection]];
totalRings=Length[theInitialValues];
}
];
Return[True]
];


(* ::Input::Initialization:: *)
getDEs:=Module[{},
theRhoDeriv=\[Psi]'[\[Rho]]==(-(D[theFunction,z]/D[theFunction,w] Exp[I \[Theta]])/.{w->\[Psi][\[Rho]],z->\[Rho] Exp[I \[Theta]]});
theThetaDeriv=\[Psi]'[\[Theta]]==(-(D[theFunction,z]/D[theFunction,w] \[Rho] I Exp[I \[Theta]])/.{w->\[Psi][\[Theta]],z->\[Rho] Exp[I \[Theta]]});
];



(* ::Input::Initialization:: *)
computeManifoldOrders:=Module[{},
totalSheets=Length[theFunctionRoots];
loopmax=2 \[Pi] totalSheets;
manifoldOrders=Table[
{rmin,rmax,wstart,wend}=theInitialValues[[ringIndex]];
currentRing=theInitialValues[[ringIndex,4]];
rnorm=(rmin+rmax)/2;
r1=rmin;
r2=rmax;
tval=thetStart;
Subscript[\[Theta], 1]=tval;
Subscript[\[Theta], 2]=tval+loopmax;
totalOrders=0;
theCurrentStepSize=theMaxStepSize;
theInitialStep=0.001;
theLoopCount=0;
While[totalOrders!=theFunctionDegree && theLoopCount<5,
{
myAzmuthalTable=Flatten[Table[
\[Psi][\[Theta]]/.NDSolve[{theThetaDeriv/.\[Rho]->rnorm,\[Psi][Subscript[\[Theta], 1]]==theFunctionRoots[[sheetnum]]/.z->rnorm Exp[I Subscript[\[Theta], 1]]},\[Psi][\[Theta]],{\[Theta],Subscript[\[Theta], 1],Subscript[\[Theta], 2]},MaxStepSize->theCurrentStepSize,MaxSteps->500000],
{sheetnum,1,totalSheets}]];

myTable1=Flatten[Table[myAzmuthalTable[[1]]/.{\[Theta]->thetStart+2 \[Pi] wnum,r->rnorm},{wnum,0,totalSheets-1}]];
list1=DeleteDuplicates[myTable1,Abs[#1-#2]<deleteDuplicateThreshold&];
manifoldList={{1,Length[list1]}};

For[i=2,i<=totalSheets,i++,
myTable2=Flatten[Table[myAzmuthalTable[[i]]/.{\[Theta]->thetStart+2 \[Pi] wnum,r->rnorm},{wnum,0,totalSheets-1}]];
list2=DeleteDuplicates[myTable2,Abs[#1-#2]<deleteDuplicateThreshold&];
If[Length[Intersection[list1,list2,
SameTest->(Abs[#1-#2]<deleteDuplicateThreshold&)]]==0,
list1=Flatten[Append[list1,list2]];
manifoldList=Append[manifoldList,{i,Length[list2]}];
];
(* check for ramification agreement *)
];
totalOrders=Plus @@ (#[[2]]& /@ manifoldList);
If[totalOrders!=theFunctionDegree,
{
Print["Ramification index error on ring ",currentRing,": ",manifoldList];
If[theLoopCount==0,
{
theCurrentStepSize=theInitialStep;
Print["Decreasing step size to ",theCurrentStepSize];
theLoopCount++;
}
,
{
theCurrentStepSize=theCurrentStepSize/2;
Print["Decreasing step size to ",theCurrentStepSize];
theLoopCount++;
}
];
}
,
theStepSizeArray[[ringIndex]]=theCurrentStepSize;
];
};
];
If[theLoopCount==5 && totalOrders!=theFunctionDegree,
Print["Unable to resolve ramification discrepancy on ring ",currentRing, " after five attempts"];
];
manifoldList,{ringIndex,1,totalRings}];
(*

*)
netorders=Table[Plus @@ manifoldOrders[[n,All,2]],{n,1,totalRings}];
ringFlagArray=Table["",{n,1,totalRings}];
For[i=1,i<=Length[manifoldOrders],i++,
itemp="";
If[netorders[[i]]!=Length[theFunctionRoots],
{
itemp="*";
ringFlagArray[[i]]="*";
}
];
];
theRingGroupTable={};
myRange=Table[{theInitialValues[[ringIndex,1]],theInitialValues[[ringIndex,2]]},{ringIndex,1,totalRings}];
myRangeSave=myRange;

For[n=1,n<=totalRings,n++,
currentRing=theInitialValues[[n,4]];
table1={};
table2={};
If[n>1,
{
For[j=1,j<=Length[thePoles],j++,
If[Abs[thePoles[[j]]]<=myRangeSave[[n,1]] && Abs[thePoles[[j]]]>=myRangeSave[[n-1,2]],
{
table1=Append[table1,Style[SetPrecision[thePoles[[j]],4],Bold,Red]];
}
]
];
For[j=1,j<=Length[theZeros],j++,
If[Abs[theZeros[[j]]]<=myRangeSave[[n,1]] && Abs[theZeros[[j]]]>=myRangeSave[[n-1,2]],
table1=Append[table1,Style[SetPrecision[theZeros[[j]],4],Bold,Darker[Green]]]]];
myRangeTemp={myRange[[n,1]]};
For[j=1,j<=Length[theZeros],j++,
If[Abs[theZeros[[j]]]<= myRange[[n,2]] && Abs[theZeros[[j]]]>= myRange[[n,1]],
myRangeTemp=Append[myRangeTemp,Style[SetPrecision[theZeros[[j]],4],Bold,Darker[Green]]]]];
myRangeTemp=Append[myRangeTemp,myRange[[n,2]]];
myRange[[n]]=myRangeTemp;
}
,
{
For[j=1,j<=Length[thePoles],j++,
If[Abs[thePoles[[j]]]<=myRange[[1,1]],
table2=Append[table2,Style[SetPrecision[thePoles[[j]],4],Bold,Red]]]];
For[j=1,j<=Length[theZeros],j++,
If[Abs[theZeros[[j]]]<myRange[[1,1]],
table2=Append[table2,Style[SetPrecision[theZeros[[j]],4],Bold,Darker[Green]]]]];
}
];
If[Length[table1]>0,
{
theRingGroupTable=Append[theRingGroupTable,{"","","",table1}];
theRingGroupTable=Append[theRingGroupTable,{ currentRing,ringFlagArray[[n]],manifoldOrders[[n]],SetPrecision[myRange[[n]],4]}];
}
];
If[Length[table2]>0,
{
theRingGroupTable=Append[theRingGroupTable,{"","","",table2}];
theRingGroupTable=Append[theRingGroupTable,{currentRing,ringFlagArray[[n]],manifoldOrders[[n]],SetPrecision[myRange[[n]],4]}];
}
];
If[Length[table1]==0 && Length[table2]==0,
theRingGroupTable=Append[theRingGroupTable,{currentRing,ringFlagArray[[n]],manifoldOrders[[n]],SetPrecision[myRange[[n]],4]}];
];
];
theRingGroupTable=Prepend[theRingGroupTable,{"Ring","","Manifold Groups", "Annular Domains"}];

Print[Grid[theRingGroupTable,Frame->True,Background->LightGray]];
If[Length[Select[netorders,# != Length[theFunctionRoots]&]]!=0,
Print["Asterisk rings have inconsistent ramification indicies"];
 ];

  If[Length[Cases[Level[theFunction,\[Infinity],Heads->True],Log]]>0 && theplotStyle==1,
{
newOrders=Flatten[Table[{{n,3},{n,-3}},{n,1,Length[theSingularPoints]}],1];
manifoldOrders[[totalRings]]=newOrders;
}
];
smax=Length[theSectorBoundaries];
nmax=Length[theInitialValues];
myrmax=theInitialValues[[nmax,2]];

If[Length[manualRingSelection]==0,
{
theInitialValues[[nmax,2]]=myrmax+outerRingSize;
theSectorBoundaries[[smax,2]]=(myrmax+outerRingSize);
}
];
];



(* ::Input::Initialization:: *)
innerManifoldOrders:=Module[{ringIndex},
totalSheets=Length[theFunctionRoots];
loopmax=2 \[Pi] totalSheets;
manifoldOrders=Table[
{rmin,rmax,wstart,wend}=theInitialValues[[ringIndex]];
currentRing=theInitialValues[[ringIndex,4]];
rnorm=(rmin+rmax)/2;
r1=rmin;
r2=rmax;
tval=thetStart;
Subscript[\[Theta], 1]=tval;
Subscript[\[Theta], 2]=tval+loopmax;
totalOrders=0;
theCurrentStepSize=theMaxStepSize;
theInitialStep=0.001;
theLoopCount=0;
While[totalOrders!=theFunctionDegree && theLoopCount<5,
{
myAzmuthalTable=Flatten[Table[
\[Psi][\[Theta]]/.NDSolve[{theThetaDeriv/.\[Rho]->rnorm,\[Psi][Subscript[\[Theta], 1]]==theFunctionRoots[[sheetnum]]/.z->rnorm Exp[I Subscript[\[Theta], 1]]},\[Psi][\[Theta]],{\[Theta],Subscript[\[Theta], 1],Subscript[\[Theta], 2]},MaxStepSize->theCurrentStepSize,MaxSteps->500000],
{sheetnum,1,totalSheets}]];

myTable1=Flatten[Table[myAzmuthalTable[[1]]/.{\[Theta]->thetStart+2 \[Pi] wnum,r->rnorm},{wnum,0,totalSheets-1}]];
list1=DeleteDuplicates[myTable1,Abs[#1-#2]<deleteDuplicateThreshold&];
manifoldList={{1,Length[list1]}};

For[i=2,i<=totalSheets,i++,
myTable2=Flatten[Table[myAzmuthalTable[[i]]/.{\[Theta]->thetStart+2 \[Pi] wnum,r->rnorm},{wnum,0,totalSheets-1}]];
list2=DeleteDuplicates[myTable2,Abs[#1-#2]<deleteDuplicateThreshold&];
If[Length[Intersection[list1,list2,
SameTest->(Abs[#1-#2]<deleteDuplicateThreshold&)]]==0,
list1=Flatten[Append[list1,list2]];
manifoldList=Append[manifoldList,{i,Length[list2]}];
];
(* check for ramification agreement *)
];
totalOrders=Plus @@ (#[[2]]& /@ manifoldList);
If[totalOrders!=theFunctionDegree,
{
Print["Ramification index error on ring ",currentRing,": ",manifoldList];
If[theLoopCount==0,
{
theCurrentStepSize=theInitialStep;
Print["Decreasing step size to ",theCurrentStepSize];
theLoopCount++;
}
,
{
theCurrentStepSize=theCurrentStepSize/2;
Print["Decreasing step size to ",theCurrentStepSize];
theLoopCount++;
}
];
}
,
theStepSizeArray[[ringIndex]]=theCurrentStepSize;
];
};
];
If[theLoopCount==5 && totalOrders!=theFunctionDegree,
Print["Unable to resolve ramification discrepancy on ring ",currentRing, " after five attempts"];
];
manifoldList,{ringIndex,1,1}]
];


(* ::Input::Initialization:: *)
innerManifoldOrders2:=Module[{ringIndex},
totalSheets=Length[theFunctionRoots];
loopmax=2 \[Pi] totalSheets;
manifoldOrders=Table[
{rmin,rmax,wstart,wend}=theInitialValues[[ringIndex]];
currentRing=theInitialValues[[ringIndex,4]];
rnorm=(rmin+rmax)/2;
r1=rmin;
r2=rmax;
tval=thetStart;
Subscript[\[Theta], 1]=tval;
Subscript[\[Theta], 2]=tval+loopmax;
totalOrders=0;
theCurrentStepSize=theMaxStepSize;
theInitialStep=0.001;
theLoopCount=0;

myAzmuthalTable=Flatten[Table[
\[Psi][\[Theta]]/.NDSolve[{theThetaDeriv/.\[Rho]->rnorm,\[Psi][Subscript[\[Theta], 1]]==theFunctionRoots[[sheetnum]]/.z->rnorm Exp[I Subscript[\[Theta], 1]]},\[Psi][\[Theta]],{\[Theta],Subscript[\[Theta], 1],Subscript[\[Theta], 2]},MaxStepSize->theCurrentStepSize,MaxSteps->500000],
{sheetnum,1,totalSheets}]];

myTable1=Flatten[Table[myAzmuthalTable[[1]]/.{\[Theta]->thetStart+2 \[Pi] wnum,r->rnorm},{wnum,0,totalSheets-1}]];
list1=DeleteDuplicates[myTable1,Abs[#1-#2]<deleteDuplicateThreshold&];
manifoldList={{1,Length[list1]}};

For[i=2,i<=totalSheets,i++,
myTable2=Flatten[Table[myAzmuthalTable[[i]]/.{\[Theta]->thetStart+2 \[Pi] wnum,r->rnorm},{wnum,0,totalSheets-1}]];
list2=DeleteDuplicates[myTable2,Abs[#1-#2]<deleteDuplicateThreshold&];
If[Length[Intersection[list1,list2,
SameTest->(Abs[#1-#2]<deleteDuplicateThreshold&)]]==0,
list1=Flatten[Append[list1,list2]];
manifoldList=Append[manifoldList,{i,Length[list2]}];
];
(* check for ramification agreement *)
];
totalOrders=Plus @@ (#[[2]]& /@ manifoldList);

If[totalOrders!=theFunctionDegree,
manifoldList={};
];
manifoldList,{ringIndex,1,1}]
];


(* ::Input::Initialization:: *)
computeRadialMultiSheet[ring_,manifold_,totalT_,totalR_]:=Module[{currentRing,rnorm,rmin,rmax},
currentRing=theInitialValues[[ring,4]];
{rmin,rmax,wstart,wend}=theInitialValues[[ring]];
rnorm=(rmin+rmax)/2;
Subscript[\[Rho], 1]=rmin;
Subscript[\[Rho], 2]=rmax;
tval=thetStart;
Subscript[\[Theta], 1]=tval;
Subscript[\[Theta], 2]=tval+manifoldOrders[[ring,manifold,2]] 2 \[Pi];
wSheet=theFunctionRoots[[manifoldOrders[[ring,manifold,1]]]];
pp\[CurlyPhi]O=totalT Abs[manifoldOrders[[ring,manifold,2]]]+1;
pprO=totalR/2;
{pp\[CurlyPhi], ppr} = {pp\[CurlyPhi]O, pprO} - 1;
mysol=First[NDSolve[{theThetaDeriv/.\[Rho]->rnorm,\[Psi][Subscript[\[Theta], 1]]==(wSheet/.z->rnorm Exp[I Subscript[\[Theta], 1]])},\[Psi],{\[Theta],Subscript[\[Theta], 1],Subscript[\[Theta], 2]},MaxStepSize->theStepSizeArray[[ring]],MaxSteps->500000]];
(* now do radial scan over branch *)
myw[t_]:=Evaluate[\[Psi][t]/.mysol];
myDataPoints=Table[
currentTheta=Subscript[\[Theta], 1] + k/pp\[CurlyPhi](Subscript[\[Theta], 2] - Subscript[\[Theta], 1]);
myRadialSolution=
{\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->currentTheta,\[Psi][rnorm]==myw[currentTheta]},\[Psi],{\[Rho],rnorm,Subscript[\[Rho], 1]},MaxStepSize->theStepSizeArray[[ring]],MaxSteps->theMaxSteps],\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->currentTheta,\[Psi][rnorm]==myw[currentTheta]},\[Psi],{\[Rho],rnorm,Subscript[\[Rho], 2]},MaxStepSize->theStepSizeArray[[ring]],MaxSteps->theMaxSteps]};

mytable1=Table[rb1 = Subscript[\[Rho], 1] + i/ppr(rnorm - Subscript[\[Rho], 1]);
 {currentTheta,Re[rb1 Exp[I currentTheta]], Im[rb1 Exp[I currentTheta]],First[myRadialSolution[[1]]/.{\[Rho]->rb1 }]}, 
                      {i,0,ppr}];

 mytable2=Table[rb2 = rnorm + i/ppr(Subscript[\[Rho], 2]-rnorm);
 {currentTheta,Re[rb2 Exp[I currentTheta]], Im[rb2 Exp[I currentTheta]], First[myRadialSolution[[2]]/.{\[Rho]->rb2 }]}, 
                      {i,1,ppr}];
Join[mytable1,mytable2],{k, 0, pp\[CurlyPhi]}];

mypTable = Map[{#[[2]], #[[3]], reim[#[[4]]]} &, myDataPoints, {2}] ;


 myTableLen = Length[mypTable];
    mList = Range[myTableLen];
    rval = Length[mypTable[[1]]];
    myPolygons = Table[Polygon[{mypTable[[mList[[i]], j]], mypTable[[mList[[i]], j + 1]], mypTable[[mList[[i + 1]], j + 1]], mypTable[[mList[[i + 1]], j]]}], {i, 1, myTableLen - 1}, {j, 1, rval - 1}]
];












(* ::Input::Initialization:: *)
computeOffsetRadialMultiSheet[ring_,manifold_,totalT_,totalR_,center_]:=Module[{currentRing,rnorm,rmin,rmax},
currentRing=theInitialValues[[ring,4]];
{rmin,rmax,wstart,wend}=theInitialValues[[ring]];
rnorm=(rmin+rmax)/2;
Subscript[\[Rho], 1]=rmin;
Subscript[\[Rho], 2]=rmax;
tval=thetStart;
Subscript[\[Theta], 1]=tval;
Subscript[\[Theta], 2]=tval+manifoldOrders[[ring,manifold,2]] 2 \[Pi];
wSheet=theFunctionRoots[[manifoldOrders[[ring,manifold,1]]]];
pp\[CurlyPhi]O=totalT Abs[manifoldOrders[[ring,manifold,2]]]+1;
pprO=totalR/2;
{pp\[CurlyPhi], ppr} = {pp\[CurlyPhi]O, pprO} - 1;
mysol=First[NDSolve[{theThetaDeriv/.\[Rho]->rnorm,\[Psi][Subscript[\[Theta], 1]]==(wSheet/.z->rnorm Exp[I Subscript[\[Theta], 1]])},\[Psi],{\[Theta],Subscript[\[Theta], 1],Subscript[\[Theta], 2]},MaxStepSize->theStepSizeArray[[ring]],MaxSteps->500000]];
(* now do radial scan over branch *)
myw[t_]:=Evaluate[\[Psi][t]/.mysol];
myDataPoints=Table[
currentTheta=Subscript[\[Theta], 1] + k/pp\[CurlyPhi](Subscript[\[Theta], 2] - Subscript[\[Theta], 1]);
myRadialSolution=
{\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->currentTheta,\[Psi][rnorm]==myw[currentTheta]},\[Psi],{\[Rho],rnorm,Subscript[\[Rho], 1]},MaxStepSize->theStepSizeArray[[ring]],MaxSteps->theMaxSteps],\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->currentTheta,\[Psi][rnorm]==myw[currentTheta]},\[Psi],{\[Rho],rnorm,Subscript[\[Rho], 2]},MaxStepSize->theStepSizeArray[[ring]],MaxSteps->theMaxSteps]};

mytable1=Table[rb1 = Subscript[\[Rho], 1] + i/ppr(rnorm - Subscript[\[Rho], 1]);
 {currentTheta,Re[(rb1) Exp[I currentTheta]]+center, Im[rb1 Exp[I currentTheta]],First[myRadialSolution[[1]]/.{\[Rho]->rb1}]}, 
                      {i,0,ppr}];

 mytable2=Table[rb2 = rnorm + i/ppr(Subscript[\[Rho], 2]-rnorm);
 {currentTheta,Re[(rb2) Exp[I currentTheta]]+center, Im[rb2 Exp[I currentTheta]], First[myRadialSolution[[2]]/.{\[Rho]->rb2}]}, 
                      {i,1,ppr}];
Join[mytable1,mytable2],{k, 0, pp\[CurlyPhi]}];

mypTable = Map[{#[[2]], #[[3]], reim[#[[4]]]} &, myDataPoints, {2}] ;


 myTableLen = Length[mypTable];
    mList = Range[myTableLen];
    rval = Length[mypTable[[1]]];
    myPolygons = Table[Polygon[{mypTable[[mList[[i]], j]], mypTable[[mList[[i]], j + 1]], mypTable[[mList[[i + 1]], j + 1]], mypTable[[mList[[i + 1]], j]]}], {i, 1, myTableLen - 1}, {j, 1, rval - 1}]
];












(* ::Input::Initialization:: *)
computeMultisheet:=Module[{},

ringTable=Table[
currentRing=theInitialValues[[ringIndex,4]];
{rmin,rmax,wstart,wend}=theInitialValues[[ringIndex]];
rnorm=(rmin+rmax)/2;
Subscript[\[Rho], 1]=rmin;
Subscript[\[Rho], 2]=rmax;
tval=thetStart;
Subscript[\[Theta], 1]=tval;
Subscript[\[Theta], 2]=tval+manifoldOrders[[ringIndex,mnum,2]] 2 \[Pi];
wSheet=theFunctionRoots[[manifoldOrders[[ringIndex,mnum,1]]]];
pp\[CurlyPhi]O=totalT Abs[manifoldOrders[[ringIndex,mnum,2]]]+1;
pprO=totalR/2;
{pp\[CurlyPhi], ppr} = {pp\[CurlyPhi]O, pprO} - 1;

radialIFs={\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->Subscript[\[Theta], 1],\[Psi][rnorm]==(wSheet/.z->rnorm Exp[I Subscript[\[Theta], 1]])},\[Psi],{\[Rho],rnorm,Subscript[\[Rho], 1]},MaxStepSize->theStepSizeArray[[ringIndex]],MaxSteps->theMaxSteps],\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->Subscript[\[Theta], 1],\[Psi][rnorm]==(wSheet/.z->rnorm Exp[I Subscript[\[Theta], 1]])},\[Psi],{\[Rho],rnorm,Subscript[\[Rho], 2]},MaxStepSize->theStepSizeArray[[ringIndex]],MaxSteps->theMaxSteps]};


myAzmuthalTable = Table[ra1 = Subscript[\[Rho], 1] + i/ppr(rnorm - Subscript[\[Rho], 1]);
ra2=rnorm+i/ppr(Subscript[\[Rho], 2]-rnorm);
{\[Psi][\[Theta]]/.NDSolve[{theThetaDeriv/.\[Rho]->ra1,\[Psi][Subscript[\[Theta], 1]]==wSheet/.z->ra1 Exp[I Subscript[\[Theta], 1]]},\[Psi],{\[Theta],Subscript[\[Theta], 1],Subscript[\[Theta], 2]},MaxStepSize->theStepSizeArray[[ringIndex]],MaxSteps->theMaxSteps],\[Psi][\[Theta]]/.NDSolve[{theThetaDeriv/.\[Rho]->ra2,\[Psi][Subscript[\[Theta], 1]]==wSheet/.z->ra2 Exp[I Subscript[\[Theta], 1]]},\[Psi],{\[Theta],Subscript[\[Theta], 1],Subscript[\[Theta], 2]},MaxStepSize->theStepSizeArray[[ringIndex]],MaxSteps->theMaxSteps]},{i, 0, ppr}];

      	   (* calculate points for the sheeet *)	
	
(*      mytable1=Table[rb1 = Subscript[\[Rho], 1] + i/ppr(rnorm - Subscript[\[Rho], 1]);
 \[CurlyPhi]b = Subscript[\[Theta], 1] + k/pp\[CurlyPhi](Subscript[\[Theta], 2] - Subscript[\[Theta], 1]); 
{\[CurlyPhi]b,Re[rb1 Exp[\[ImaginaryI] \[CurlyPhi]b]], Im[rb1 Exp[\[ImaginaryI] \[CurlyPhi]b]],First[myAzmuthalTable[[i+1,1]]/.{\[Theta]\[Rule] \[CurlyPhi]b }]}, 
                      {k, 0, pp\[CurlyPhi]},{i,0,ppr}];

 mytable2=Table[rb2 = rnorm + i/ppr(Subscript[\[Rho], 2]-rnorm);
 \[CurlyPhi]b = Subscript[\[Theta], 1] + k/pp\[CurlyPhi](Subscript[\[Theta], 2] -Subscript[\[Theta], 1]); 
{\[CurlyPhi]b,Re[rb2 Exp[\[ImaginaryI] \[CurlyPhi]b]], Im[rb2 Exp[\[ImaginaryI] \[CurlyPhi]b]], First[myAzmuthalTable[[i+1,2]]/.{\[Theta]\[Rule] \[CurlyPhi]b }]}, 
                      {k, 0, pp\[CurlyPhi]},{i,0,ppr}];
*)
theResults=0;

newTable=Table[ \[CurlyPhi]b = Subscript[\[Theta], 1] + k/pp\[CurlyPhi](Subscript[\[Theta], 2] - Subscript[\[Theta], 1]); 
If[i<= ppr,
{
therb = Subscript[\[Rho], 1] + i/ppr(rnorm - Subscript[\[Rho], 1]);
theResults={\[CurlyPhi]b,Re[therb Exp[I \[CurlyPhi]b]], Im[therb Exp[I \[CurlyPhi]b]], First[myAzmuthalTable[[i+1,1]]/.{\[Theta]-> \[CurlyPhi]b }]};
}
,
{
therb= rnorm + (i-ppr-1)/ppr(Subscript[\[Rho], 2]-rnorm);
theResults={\[CurlyPhi]b,Re[therb Exp[I \[CurlyPhi]b]], Im[therb Exp[I \[CurlyPhi]b]], First[myAzmuthalTable[[i-ppr,2]]/.{\[Theta]-> \[CurlyPhi]b }]};
}
];
theResults,{k, 0, pp\[CurlyPhi]},{i,0,totalR-1}];
newTable,{ringIndex,1,totalRings},{mnum,1,Length[manifoldOrders[[ringIndex]]]}];

];



(* ::Input::Initialization:: *)
computeEtaMultisheet:=Module[{},

ringTable=Table[
currentRing=theInitialValues[[ringIndex,4]];
{rmin,rmax,wstart,wend}=theInitialValues[[ringIndex]];
rnorm=(rmin+rmax)/2;
Subscript[\[Rho], 1]=rmin;
Subscript[\[Rho], 2]=rmax;
tval=thetStart;
Subscript[\[Theta], 1]=tval;
Subscript[\[Theta], 2]=tval+manifoldOrders[[ringIndex,mnum,2]] 2 \[Pi];
wSheet=theFunctionRoots[[manifoldOrders[[ringIndex,mnum,1]]]];
pp\[CurlyPhi]O=totalT Abs[manifoldOrders[[ringIndex,mnum,2]]]+1;
pprO=totalR/2;
{pp\[CurlyPhi], ppr} = {pp\[CurlyPhi]O, pprO} - 1;

radialIFs={\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->Subscript[\[Theta], 1],\[Psi][rnorm]==(wSheet/.z->rnorm Exp[I Subscript[\[Theta], 1]])},\[Psi],{\[Rho],rnorm,Subscript[\[Rho], 1]},MaxStepSize->theStepSizeArray[[ringIndex]],MaxSteps->theMaxSteps],\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->Subscript[\[Theta], 1],\[Psi][rnorm]==(wSheet/.z->rnorm Exp[I Subscript[\[Theta], 1]])},\[Psi],{\[Rho],rnorm,Subscript[\[Rho], 2]},MaxStepSize->theStepSizeArray[[ringIndex]],MaxSteps->theMaxSteps]};


myAzmuthalTable = Table[ra1 = Subscript[\[Rho], 1] + i/ppr(rnorm - Subscript[\[Rho], 1]);
ra2=rnorm+i/ppr(Subscript[\[Rho], 2]-rnorm);
{\[Psi][\[Theta]]/.NDSolve[{theThetaDeriv/.\[Rho]->ra1,\[Psi][Subscript[\[Theta], 1]]==wSheet/.z->ra1 Exp[I Subscript[\[Theta], 1]]},\[Psi],{\[Theta],Subscript[\[Theta], 1],Subscript[\[Theta], 2]},MaxStepSize->theStepSizeArray[[ringIndex]],MaxSteps->theMaxSteps],\[Psi][\[Theta]]/.NDSolve[{theThetaDeriv/.\[Rho]->ra2,\[Psi][Subscript[\[Theta], 1]]==wSheet/.z->ra2 Exp[I Subscript[\[Theta], 1]]},\[Psi],{\[Theta],Subscript[\[Theta], 1],Subscript[\[Theta], 2]},MaxStepSize->theStepSizeArray[[ringIndex]],MaxSteps->theMaxSteps]},{i, 0, ppr}];

      	   (* calculate points for the sheeet *)	
	
      mytable1=Table[rb1 = Subscript[\[Rho], 1] + i/ppr(rnorm - Subscript[\[Rho], 1]);
 \[CurlyPhi]b = Subscript[\[Theta], 1] + k/pp\[CurlyPhi](Subscript[\[Theta], 2] - Subscript[\[Theta], 1]); 
{\[CurlyPhi]b,Re[rb1 Exp[I \[CurlyPhi]b]], Im[rb1 Exp[I \[CurlyPhi]b]],myEtaFunction[rb1 Exp[I \[CurlyPhi]b],First[myAzmuthalTable[[i+1,1]]/.{\[Theta]-> \[CurlyPhi]b }]]}, 
                      {i,0,ppr},{k, 0, pp\[CurlyPhi]}];

 mytable2=Table[rb2 = rnorm + i/ppr(Subscript[\[Rho], 2]-rnorm);
 \[CurlyPhi]b = Subscript[\[Theta], 1] + k/pp\[CurlyPhi](Subscript[\[Theta], 2] -Subscript[\[Theta], 1]); 
{\[CurlyPhi]b,Re[rb2 Exp[I \[CurlyPhi]b]], Im[rb2 Exp[I \[CurlyPhi]b]], myEtaFunction[rb2 Exp[I \[CurlyPhi]b],First[myAzmuthalTable[[i+1,2]]/.{\[Theta]-> \[CurlyPhi]b }]]}, 
                      {i,1,ppr},{k, 0, pp\[CurlyPhi]}];
Join[mytable1,mytable2],{ringIndex,1,totalRings},{mnum,1,Length[manifoldOrders[[ringIndex]]]}];

];



(* ::Input::Initialization:: *)
extractreimComponent:=Module[{},
If[Length[editSectorLatch]==0,
Print["test"];
{
theMultiS = Table[totalManifolds = Length[ringTable[[ringnum]]];
   Table[
    myManifolds = ringTable[[ringnum]];
    
    mypTable = Map[{#[[2]], #[[3]], reim[#[[4]]]} &, myManifolds[[manifoldnum]], {2}] ;
    
  
    myTableLen = Length[mypTable];
    mList = Range[myTableLen];
    rval = Length[mypTable[[1]]];
    myPolygons = Table[Polygon[{mypTable[[mList[[i]], j]], mypTable[[mList[[i]], j + 1]], mypTable[[mList[[i + 1]], j + 1]], mypTable[[mList[[i + 1]], j]]}], {i, 1, myTableLen - 1}, {j, 1, rval - 1}], {manifoldnum, 1, totalManifolds}], {ringnum, 1, totalRings}];


}
];
];




(* ::Input::Initialization:: *)
autoEvaluate:=Module[{},
If[identifySingularities,
{
getDEs;
computeManifoldOrders;
computeMultisheet;
extractreimComponent;
Print["Auto evaluate Completed"];
}
];
];



(* ::Input::Initialization:: *)
autoEtaEvaluate:=Module[{},
If[identifySingularities,
{
getDEs;
computeManifoldOrders;
computeEtaMultisheet;
extractreimComponent;
Print["Auto evaluate Completed"];
}
];
];



(* ::Input::Initialization:: *)
identicalComplexNumQ[n1_,n2_]:=Module[{},
If[Abs[Re[n1]-Re[n2]]<0.001 &&Abs[Im[n1]-Im[n2]]<0.001,
True
,
False
]
]



(* ::Input::Initialization:: *)
generateRiemannPlot:=Module[{},
extractreimComponent;
If[theplotStyle==1,
sheetTable=Table[MapThread[{#1,#2}&,{Table[Lighter[theColorList[[n,1]]],{Length[theMultiS[[n]]]}],theMultiS[[n]]}],{n,1,totalRings}];
,
sheetTable=Table[MapThread[{#1,#2}&,{Take[theColorList[[n]],Length[theMultiS[[n]]]],theMultiS[[n]]}],{n,1,totalRings}];
];
If[theplotStyle==0,
{xmax=sectorboundaries[[Max[ringval],2]];
theaxesRange={{-xmax,xmax},{-xmax,xmax},{-5,5}};
}
,
theaxesRange={{xStart,xEnd},{yStart,yEnd},{-15,15}};
];
If[theInverse,theaxesRange={{-5,5},{-5,5},{-10,10}}];
If[theplotFlag==0,
theplotrange=Automatic
,
theplotrange=theplotRange
];
       If[theOpacity==0,
theGraphicsData=Graphics3D[Table[sheetTable[[ringval[[thering]],theCheckTable[ringval[[thering]]][[theman]]]],{thering,1,Length[ringval]},{theman,1,Length[theCheckTable[ringval[[thering]]]]}]];
,
theGraphicsData=Graphics3D[{Opacity[theOpacity],Table[sheetTable[[ringval[[thering]],theCheckTable[ringval[[thering]]][[theman]]]],{thering,1,Length[ringval]},{theman,1,Length[theCheckTable[ringval[[thering]]]]}]}];
];
(* do startofbranch points here *)
If[startOfBranch==1,
{
Print["ringval: ",ringval[[1]]];
Print[theCheckTable[ringval[[1]]]];
startofbranchtable=Table[
{rmin,rmax,wstart,wend}=theInitialValues[[ringval[[thering]]]];
rnorm=(rmin+rmax)/2;
z0=rnorm Exp[I thetStart];
bpoints=theFunctionRoots[[manifoldOrders[[ringval[[thering]],theCheckTable[ringval[[theman]]],1]]]]/.z->z0;
startPoint=Point[{Re[z0],Im[z0],reim[First[bpoints]]}],
{thering,1,Length[ringval]},{theman,1,Length[theCheckTable[ringval[[thering]]]]}];
theGraphicsData={theGraphicsData,Graphics3D[{PointSize[0.03],Black,startofbranchtable}]};
}
];

(*theGraphicsData={theGraphicsData,combo};*)
If[Length[theTraceLatch]>0,
If[trace1Latch==True,
theGraphicsData={theGraphicsData,theTrace1};
];
If[trace2Latch==True,
theGraphicsData={theGraphicsData,theTrace2};
];
If[trace3Latch==True,
theGraphicsData={theGraphicsData,theTrace3};
];
If[trace4Latch==True,
theGraphicsData={theGraphicsData,theTrace4};
];
If[trace5Latch==True,
theGraphicsData={theGraphicsData,theTrace5};
];
If[trace6Latch==True,
theGraphicsData={theGraphicsData,theTrace6};
];
If[trace7Latch==True,
theGraphicsData={theGraphicsData,theTrace7};
];
If[trace8Latch==True,
theGraphicsData={theGraphicsData,theTrace8};
];
];

theRiemannPlot=Show[theGraphicsData,Axes->True,
                     AxesEdge->{{-1,-1},{1,-1},{1,1}},
                     AxesLabel->{Style["x",16],Style["y",16],Style[reim,16]},
                     Lighting->"Neutral",
                      BoxRatios->theBoxRatios,
PlotRange->theplotrange,
		                     ImageSize->theImageSize]
];



(* ::Input::Initialization:: *)
showSingularPlot=Module[{},
mystartpath={Darker[Green],Thickness[0.008],Table[Line[{{Re[theInitialValues[[n,3]]],Im[theInitialValues[[n,3]]]},{Re[theInitialValues[[n,4]]],Im[theInitialValues[[n,4]]]}}],{n,1,Length[theInitialValues]}]};

theSectorPic=Show[Graphics[{mycircles,wPoints,mystartpath}],Axes->True,PlotRange->All]
];



(* ::Input::Initialization:: *)
editLogOrders=Module[{},
Clear[mOrders];
netrings={Table[{n,InputField[Dynamic[Evaluate[mOrders[n]]],FieldSize->40]},{n,1,totalRings}]};
For[n=1,n<=totalRings,n++,
mOrders[n]=manifoldOrders[[n]];
];
mynetrings=Flatten[netrings,1];

theGrid=Prepend[mynetrings,{Style["Rings"],Style["Manifold List: {{r1,m1},{r1,m2},...{rn,mn}}"]}];
theGrid=Append[theGrid,{Button["Update Manifold List",updateFromLogEdit]}];
Grid[theGrid]
];



(* ::Input::Initialization:: *)
getDisplayGrid:=Module[{},
Clear[theCheckTable];
ringSize=Length[ringTable];
myManifoldCheckList=Table[CheckboxBar[Dynamic[Evaluate[theCheckTable[n]]],Flatten[{Table[ToRules[i==Style["{"<>ToString[manifoldOrders[[n,i,1]]]<>","<>ToString[If[!IntegerQ[manifoldOrders[[n,i,2]]],manifoldOrders[[n,i,2]]+0.0,manifoldOrders[[n,i,2]]]]<>"}",FontColor->Darker[theColorList[[n,i]]]]],{i,1,Length[manifoldOrders[[n]]]}]}]],{n,1,ringSize}];

myRange=Table[{theInitialValues[[ringnum,1]],theInitialValues[[ringnum,2]]},{ringnum,1,ringSize}];


For[n=1,n<=Length[ringTable],n++,
theCheckTable[n]=Range[Length[ringTable[[n]]]];
];
ringval=Range[ringSize];
theRingChecks=Table[CheckboxBar[Dynamic[ringval],{n->Style[ToString[theInitialValues[[n,4]]]<>" "<>ringFlagArray[[n]]]}],{n,1,Length[manifoldOrders]}];
theTitle=If[theplotStyle==0,"Manifolds","Holomorphic Branches"];
theBlock={};
For[n=1,n<=ringSize,n++,
table1={};
table2={};
If[n>1,
{
For[j=1,j<=Length[thePoles],j++,
If[Abs[thePoles[[j]]]<myRange[[n,1]] && Abs[thePoles[[j]]]>myRange[[n-1,2]],
table1=Append[table1,Style[thePoles[[j]],Bold,Red]]]];
For[j=1,j<=Length[theZeros],j++,
If[Abs[theZeros[[j]]]<myRange[[n,1]] && Abs[theZeros[[j]]]>myRange[[n-1,2]],
table1=Append[table1,Style[theZeros[[j]],Bold,Darker[Green]]]]];
myRangeTemp={myRange[[n,1]]};
For[j=1,j<=Length[theZeros],j++,
If[Abs[theZeros[[j]]]<= myRange[[n,2]] && Abs[theZeros[[j]]]>= myRange[[n,1]],
myRangeTemp=Append[myRangeTemp,Style[theZeros[[j]],Bold,Darker[Green]]]]];
myRangeTemp=Append[myRangeTemp,myRange[[n,2]]];
myRange[[n]]=myRangeTemp;
}
,
{
For[j=1,j<=Length[thePoles],j++,
If[Abs[thePoles[[j]]]<myRange[[1,1]],
table2=Append[table2,Style[thePoles[[j]],Bold,Red]]]];
For[j=1,j<=Length[theZeros],j++,
If[Abs[theZeros[[j]]]<myRange[[1,1]],
table2=Append[table2,Style[theZeros[[j]],Bold,Darker[Green]]]]];
}
];
If[Length[table1]>0,
{
theBlock=Append[theBlock,{"","",table1}];
theBlock=Append[theBlock,{theRingChecks[[n]],myManifoldCheckList[[n]],myRange[[n]]}];
}
];
If[Length[table2]>0,
{
theBlock=Append[theBlock,{"","",table2}];
theBlock=Append[theBlock,{theRingChecks[[n]],myManifoldCheckList[[n]],myRange[[n]]}];
}
];
If[Length[table1]==0 && Length[table2]==0,
theBlock=Append[theBlock,{theRingChecks[[n]],myManifoldCheckList[[n]],myRange[[n]]}];
];
];
theGrid2=theBlock;

(*theGrid2=Table[{theRingChecks[[n]],myManifoldCheckList[[n]],myRange[[n]]},{n,1,ringSize}];*)
theGrid2=Prepend[theGrid2,{Style["Rings"],Style[theTitle],Style["Range"]}];
theGrid2=Prepend[theGrid2,{Style["Choose Sheets:",16]}];
theGrid2=Append[theGrid2,{CheckboxBar[Dynamic[theTraceLatch],{1->"Enable Trace"}]}];
theGrid2=Append[theGrid2,{CheckboxBar[Dynamic[editSectorLatch],{1->"Plot Edited Sectors"}]}];
theGrid2=Append[theGrid2,{RadioButtonBar[Dynamic[reim],{Re->"Real",Im->"Imaginary"}]}];
theGrid2=Append[theGrid2,{Style["Plot Range:"]}];
theGrid2=Append[theGrid2,{RadioButtonBar[Dynamic[theplotFlag],{0->"Auto",1->"Man"}],InputField[Dynamic[theplotRange],FieldSize->20]}];
theGrid2=Append[theGrid2,{Style["Box Ratios:"],InputField[Dynamic[theBoxRatios],FieldSize->20]}];
theGrid2=Append[theGrid2,{Style["Image Size:"],InputField[Dynamic[theImageSize],FieldSize->20]}];
theGrid2=Append[theGrid2,{Style["Opacity:"],InputField[Dynamic[theOpacity],FieldSize->3]}];
theGrid2=Append[theGrid2,{Style["Show manifold base pt:"],RadioButtonBar[Dynamic[startOfBranch],{1->"Yes",0->"No"}]}];
theGrid2=Prepend[theGrid2,{Button["Clear Checks",Clear[ringval]]}]
];








(* ::Input::Initialization:: *)
polyForm[poly_,var_]:=Module[{coeffs=CoefficientRules[poly,var]//Sort},Interpretation[Row[Table[Row[{"(",coeff[[2]],")",var^coeff[[1,1]]/.1->""}],{coeff,coeffs}],"+"],poly]]


(* ::Input::Initialization:: *)
getTheOrder[p_]:=Module[{clist,theorder,j},
clist=CoefficientList[p,z];
theorder=\[Infinity];
If[Length[clist]!=0,
{
j=0;
While[clist[[j+1]]==0 && (j+1)<= Length[clist],
{
j++;
}
];
theorder=j;
}
,
theorder=\[Infinity];
];
theorder
];



(* ::Input::Initialization:: *)
getMinZExponent[p_]:=Module[{},
Exponent[p,z,Min[#&]]
];


(* ::Input::Initialization:: *)
convertToNormalForm[p_]:=Module[{mymu,temp,flag,mylambda,thepoly,degree,currentmu,mychecks,mynegs,theclist,theOrders},
theclist=CoefficientList[p,w];
degree=Length[theclist]-1;
mylambda=0;
theOrders=Table[getTheOrder[theclist[[n+1]]],{n,0,degree}];
If[theOrders[[degree+1]]!=0,
{
mymu[n_,\[Lambda]_]:=n \[Lambda]-theOrders[[degree+1]];
flag=False;
While[flag==False,
mylambda++;
currentmu=mymu[degree,mylambda];
mychecks=Table[currentmu+theOrders[[i]]-(i-1) mylambda,{i,2,degree}];
mynegs=Select[mychecks,#<0&];
If[Length[mynegs]>0,
flag=False;
,
flag=True;
];
];
thepoly=Expand[z^currentmu(p/.w->w/(z^mylambda))];
}
,
thepoly=p;
];
{thepoly,mylambda}
];


(* ::Input::Initialization:: *)
lowerConvexHull[ls_]:=
Module[{
v=Quiet[ComputationalGeometry`ConvexHull[ls]],ks,min,max,left,right,pp},ks=ls[[v]];
min=Min[ks[[All,1]]];
pp=Position[ks,{min,_}];
left=Last[pp][[1]];
Append[Take[ks,left-Length[ks]-1],First[ks]]];


(* ::Input::Initialization:: *)
getBranchRoots[ringNum_,mnum_,zval_]:=Module[{rmin,rmax,wstart,wend,rstart,rend,tval,rnum,wSheet,rnorm,theorder,therStart,thewStart,tstart,tend,mysol,myw,myfirstw,mysola,mysolb,therho,thezr,thezt},
{rmin,rmax,wstart,wend}=theInitialValues[[ringNum]];
theorder=manifoldOrders[[ringNum,mnum,2]];
rnorm=(rmin+rmax)/2;
rstart=rmin;
rend=rmax;
(* need to check if thetStart is zero *)
If[thetStart !=0,
Print["Algorithm error:  set up only for thetStart=0."];
];
tval=thetStart;
rnum=rend;
thezr=Abs[zval];
thezt=Arg[zval];

(* do contour on c1 to rho of zval *)
wSheet=theFunctionRoots[[manifoldOrders[[ringNum,mnum,1]]]];
myRadialTable={\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->tval,\[Psi][rnorm]==(wSheet/.z->rnorm Exp[I tval])},\[Psi],{\[Rho],rnorm,rstart}],\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->tval,\[Psi][rnorm]==(wSheet/.z->rnorm Exp[I tval])},\[Psi],{\[Rho],rnorm,rend}]};

(* now get start of radial integration based on r value of zval *)
If[thezr<rnorm,
thewStart=First[myRadialTable[[1]]/.\[Rho]->thezr];
,
thewStart=First[myRadialTable[[2]]/.\[Rho]->thezr];
];
(* now have rstart equal to r value of myzvalue *)
(* now get analytically continuous path to w(z0)*)
tstart=thetStart;

mysola=First[NDSolve[{theThetaDeriv/.\[Rho]->thezr,\[Psi][tstart]==thewStart},\[Psi],{\[Theta],tstart,thezt}]];
myw[t_]:=Evaluate[\[Psi][t]/.mysola];

myfirstw=myw[thezt];

tstart=Arg[myfirstw];
tend=tstart+2 theorder \[Pi];

mysolb=First[NDSolve[{theThetaDeriv/.\[Rho]->thezr,\[Psi][thezt]==myfirstw},\[Psi],{\[Theta],thezt,thezt+2 theorder \[Pi]}]];
myw[t_]:=Evaluate[\[Psi][t]/.mysolb];
(* now get list of roots for this branch at myzvalue *)
Table[myw[t],{t,thezt,thezt+2 (theorder-1) \[Pi],2\[Pi]}]
];


(* ::Input::Initialization:: *)
getStartBranchPoint[ringNum_,mnum_,zval_]:=Module[{rmin,rmax,wstart,wend,rstart,rend,tval,rnum,wSheet,rnorm,theorder,therStart,thewStart,tstart,tend,mysol,myw},
{rmin,rmax,wstart,wend}=theInitialValues[[ringNum]];
theorder=manifoldOrders[[ringNum,mnum,2]];
rnorm=(rmin+rmax)/2;
rstart=rmin;
rend=rmax;
(* need to check if thetStart is zero *)
If[thetStart !=0,
Print["Algorithm error:  set up only for thetStart=0."];
];
tval=thetStart;
rnum=rend;
thezr=Abs[zval];
thezt=Arg[zval];


wSheet=theFunctionRoots[[manifoldOrders[[ringNum,mnum,1]]]];
myRadialTable={\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->tval,\[Psi][rnorm]==(wSheet/.z->rnorm Exp[I tval])},\[Psi],{\[Rho],rnorm,rstart}],\[Psi][\[Rho]]/.NDSolve[{theRhoDeriv/.\[Theta]->tval,\[Psi][rnorm]==(wSheet/.z->rnorm Exp[I tval])},\[Psi],{\[Rho],rnorm,rend}]};
(* now get start of radial integration based on r value of myzstart *)


If[thezr<rnorm,
thewStart=First[myRadialTable[[1]]/.\[Rho]->thezr];
,
thewStart=First[myRadialTable[[2]]/.\[Rho]->thezr];
];
(* now have rstart equal to r value of myzvalue *)

tstart=tval;
tend=tval+2 theorder \[Pi];

mysol=First[NDSolve[{theThetaDeriv/.\[Rho]->thezr,\[Psi][tstart]==thewStart},\[Psi],{\[Theta],tstart,thezt}]];
myw[t_]:=Evaluate[\[Psi][t]/.mysol];
(* now get list of roots for this branch at myzvalue *)
myw[thezt]
];


myManifolds=ringTable[[2]];
myManifolds[[1,1]]


updateSectors:=Module[{},
totalRings=Length[ringTable];
Print["inside module"];

theMultiS=Table[totalManifolds=Length[ringTable[[ringnum]]];
Table[
myManifolds=ringTable[[ringnum]];
If[Length[ringTable[[1,1,1,1,4]]]==0,
    mypTable = Map[{#[[2]], #[[3]], reim[#[[4]]]} &, myManifolds[[manifoldnum]], {2}], 
    (* sometimes need to add these two lines: *)
     mypTable=Map[{#[[2]],#[[3]],reim[First[#[[4]]]]}&,myManifolds[[manifoldnum]],{2}]
]; 
myTableLen=Length[mypTable];
mList=Range[myTableLen];
rval=Length[mypTable[[1]]];
myPolygons=Table[Polygon[{mypTable[[mList[[i]],j]],mypTable[[mList[[i]],j+1]],mypTable[[mList[[i+1]],j+1]],mypTable[[mList[[i+1]],j]]}],{i,1,myTableLen-1},{j,1,rval-1}],{manifoldnum,1,totalManifolds}],{ringnum,1,totalRings}];


For[ringnum=1,ringnum<=totalRings,ringnum++,
For[manifold=1,manifold<=Length[ringTable[[ringnum]]],manifold++,
If[Length[manifoldCheck[ringnum,manifold]]==1,
mypTable=Map[{#[[1]],#[[2]],#[[3]],reim[#[[4]]]}&,ringTable[[ringnum,manifold]],{2}];
(*mypTable=ringTable[[ringnum,manifold]];*)
totalArcs=Length[mypTable];
totalManifoldLength=mypTable[[totalArcs,1,1]];
netPolygons={};
For[segmentnum=1,segmentnum<= Length[manifoldAngles[ringnum,manifold]],segmentnum++,
startangle=manifoldAngles[ringnum,manifold][[segmentnum,1]];
endangle=manifoldAngles[ringnum,manifold][[segmentnum,2]];
(*startangle=manifoldAngles[ringnum,manifold,1];*)
(*endangle=manifoldAngles[ringnum,manifold,2];*)
startangle-=0.001;
endangle-=0.001;
Print[startangle];
Print[endangle];
If[startangle>endangle,
Print["Error with angles"];
,
If[startangle>0 && endangle>0,
\!\(\*
TagBox[
RowBox[{"theStartPoint", "=", 
RowBox[{
RowBox[{"Position", "[", 
RowBox[{
RowBox[{"mypTable", "[", 
RowBox[{"[", 
RowBox[{"All", ",", "1", ",", "1"}], "]"}], "]"}], ",", 
RowBox[{"a_", "/;", 
RowBox[{"a", ">=", "startangle"}]}], ",", "1", ",", "1"}], "]"}], "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}]}],
DisplayForm]\);
If[endangle<= totalManifoldLength,
\!\(\*
TagBox[
RowBox[{"theEndPoint", "=", 
RowBox[{
RowBox[{"Position", "[", 
RowBox[{
RowBox[{"mypTable", "[", 
RowBox[{"[", 
RowBox[{"All", ",", "1", ",", "1"}], "]"}], "]"}], ",", 
RowBox[{"a_", "/;", 
RowBox[{"a", ">=", "endangle"}]}], ",", "1", ",", "1"}], "]"}], "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}]}],
DisplayForm]\);
mList=Range[theStartPoint,theEndPoint];
,
endangle=endangle-totalManifoldLength;
\!\(\*
TagBox[
RowBox[{"theEndPoint", "=", 
RowBox[{
RowBox[{"Position", "[", 
RowBox[{
RowBox[{"mypTable", "[", 
RowBox[{"[", 
RowBox[{"All", ",", "1", ",", "1"}], "]"}], "]"}], ",", 
RowBox[{"a_", "/;", 
RowBox[{"a", ">=", "endangle"}]}], ",", "1", ",", "1"}], "]"}], "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}]}],
DisplayForm]\);
mList=Join[Range[theStartPoint,totalArcs],Range[1,theEndPoint]];
];
];
If[startangle<0 && endangle>0,
startangle=totalManifoldLength+startangle;
\!\(\*
TagBox[
RowBox[{"theStartPoint", "=", 
RowBox[{
RowBox[{"Position", "[", 
RowBox[{
RowBox[{"mypTable", "[", 
RowBox[{"[", 
RowBox[{"All", ",", "1", ",", "1"}], "]"}], "]"}], ",", 
RowBox[{"a_", "/;", 
RowBox[{"a", ">=", "startangle"}]}], ",", "1", ",", "1"}], "]"}], "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}]}],
DisplayForm]\);
\!\(\*
TagBox[
RowBox[{"theEndPoint", "=", 
RowBox[{
RowBox[{"Position", "[", 
RowBox[{
RowBox[{"mypTable", "[", 
RowBox[{"[", 
RowBox[{"All", ",", "1", ",", "1"}], "]"}], "]"}], ",", 
RowBox[{"a_", "/;", 
RowBox[{"a", ">=", "endangle"}]}], ",", "1", ",", "1"}], "]"}], "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}]}],
DisplayForm]\);
mList=Join[Range[theStartPoint,totalArcs],Range[1,theEndPoint]];
];
If[startangle<0 && endangle<0,
If[startangle<endangle,
(* do A here *)
startangle=totalManifoldLength+startangle;
endangle=totalManifoldLength+endangle;
\!\(\*
TagBox[
RowBox[{"theStartPoint", "=", 
RowBox[{
RowBox[{"Position", "[", 
RowBox[{
RowBox[{"mypTable", "[", 
RowBox[{"[", 
RowBox[{"All", ",", "1", ",", "1"}], "]"}], "]"}], ",", 
RowBox[{"a_", "/;", 
RowBox[{"a", ">=", "startangle"}]}], ",", "1", ",", "1"}], "]"}], "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}]}],
DisplayForm]\);
\!\(\*
TagBox[
RowBox[{"theEndPoint", "=", 
RowBox[{
RowBox[{"Position", "[", 
RowBox[{
RowBox[{"mypTable", "[", 
RowBox[{"[", 
RowBox[{"All", ",", "1", ",", "1"}], "]"}], "]"}], ",", 
RowBox[{"a_", "/;", 
RowBox[{"a", ">=", "endangle"}]}], ",", "1", ",", "1"}], "]"}], "[", 
RowBox[{"[", 
RowBox[{"1", ",", "1"}], "]"}], "]"}]}],
DisplayForm]\);
mList=Range[theStartPoint,theEndPoint];
,
(* if both negative, then startangle has to be less than endangle *)
Print["Error with angles"];
];
];
];
mynewStartList=Table[Flatten[{startangle,getNewPoints[Take[mypTable[[theStartPoint-1,n]],{2,4}],Take[mypTable[[theStartPoint,n]],{2,4}],startangle]}],{n,1,rval}];
mypTable[[theStartPoint]]=mynewStartList;
\!\(\*
TagBox[
RowBox[{"mynewEndList", "=", 
RowBox[{"Table", "[", 
RowBox[{
RowBox[{"Flatten", "[", 
RowBox[{"{", 
RowBox[{"endangle", ",", 
RowBox[{"getNewPoints", "[", 
RowBox[{
RowBox[{"Take", "[", 
RowBox[{
RowBox[{"mypTable", "[", 
RowBox[{"[", 
RowBox[{
RowBox[{"theEndPoint", "-", "1"}], ",", "n"}], "]"}], "]"}], ",", 
RowBox[{"{", 
RowBox[{"2", ",", "4"}], "}"}]}], "]"}], ",", 
RowBox[{"Take", "[", 
RowBox[{
RowBox[{"mypTable", "[", 
RowBox[{"[", 
RowBox[{"theEndPoint", ",", "n"}], "]"}], "]"}], ",", 
RowBox[{"{", 
RowBox[{"2", ",", "4"}], "}"}]}], "]"}], ",", "endangle"}], "]"}]}], "}"}], "]"}], ",", 
RowBox[{"{", 
RowBox[{"n", ",", "1", ",", "rval"}], "}"}]}], "]"}]}],
DisplayForm]\);
mypTable[[theEndPoint]]=mynewEndList;
		myTabLen=Length[mList];
netPolygons=Append[netPolygons,Table[Polygon[{Take[mypTable[[mList[[i]],j]],{2,4}],Take[mypTable[[mList[[i]],j+1]],{2,4}],Take[mypTable[[mList[[i+1]],j+1]],{2,4}],Take[mypTable[[mList[[i+1]],j]],{2,4}]}],{i,1,myTabLen-1},{j,1,rval-1}]];
];
theMultiS[[ringnum,manifold]]=netPolygons;
(* do the update of this manifold *)
];
];
];
];



getContinuousBranch[function_,value_,terms_]:=Module[{n,thevalue},
For[n=1,n<=terms,n++
If[Exp[Mod[function n,2\[Pi] I,0]]==Exp[value],
thevalue=n;
];
];
thevalue
];
getContinuousBranch2[function_,value_,terms_]:=Module[{n,thevalue},
n=1;
thevalue=-1;
While[Exp[Mod[function n,2\[Pi]]]!=Exp[value] && n<= terms,
n++;
thevalue=n;
];
thevalue
];


 ParametricPlot[{x,x-1},{x,-5,5}]





getNearestValue[series_,test_,minSepTolerance_]:=Module[{themin,i,dif,thelocation,smallestdif,mylist,currentmin,theminseparation},
themin=10^(10);
smallestdif=10^(100);
If[Length[series]<2,
Print[Style["Cannot take nearest values with series of length one!",Red]];
];
For[i=1,i<=Length[series],i++,
mylist=DeleteCases[Range[Length[series]],i];
currentmin=Min[Table[Abs[series[[i]]-mylist[[j]]],{j,1,Length[series]-1}]];
If[currentmin<smallestdif,
smallestdif=currentmin;
];
];

For[i=1,i<=Length[series],i++,
dif=Abs[series[[i]]-test];
If[dif<themin,
{
themin=dif;
thelocation=i;
}
];
];
(* now check to make sure the agreement is less than minSep *)


If[themin>minSepTolerance,
Throw[Print[Style[flagType,Red],": ",Style[" Nearest value greater than min separation tolerance! ",Bold],"Minimum separation: ",N[themin,10]," Nearest difference: ",N[themin,10]],"ContinuationCatch"];
];

{thelocation,themin}
];




(* ::Input::Initialization:: *)
updateFromLogEdit:=Module[{},
{
For[n=1,n<=totalRings,n++,
manifoldOrders[[n]]=mOrders[n]];
computeMultisheet;
extractreimComponent;
};
];
